<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>AR Видео с кнопками</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.rawgit.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <style>
    body { margin:0; overflow:hidden; }
    #fileInput {
      position:fixed; top:10px; left:50%; transform:translateX(-50%);
      z-index:10; background: rgba(0,0,0,0.5); color:white; padding:5px 10px; border-radius:5px;
    }
  </style>
</head>
<body>
<input type="file" id="fileInput" accept="video/*">

<a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;'>
  <a-entity id="camera" camera look-controls></a-entity>
</a-scene>

<script>
const scene = document.querySelector('a-scene');
const fileInput = document.getElementById('fileInput');

let videoEl, videoMesh, videoTexture;
let videoWidth = 1, videoHeight = 0.6;
let firstInteraction = true;
let buttonGroup = null;

const buttonsData = [
  {name:'Произвести', action:()=>videoEl.play()},
  {name:'Пауза', action:()=>videoEl.pause()},
  {name:'+5', action:()=>videoEl.currentTime+=5},
  {name:'-5', action:()=>videoEl.currentTime-=5},
];

// ------------------- Загрузка видео -------------------
fileInput.addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  const url = URL.createObjectURL(file);

  videoEl = document.createElement('video');
  videoEl.src = url;
  videoEl.loop = true;
  videoEl.muted = false;
  videoEl.playsInline = true;
  videoEl.crossOrigin = 'anonymous';

  videoEl.addEventListener('loadeddata', () => {
    videoWidth = videoEl.videoWidth / videoEl.videoHeight;
    videoHeight = 1;

    if(!videoMesh){
      const geometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
      videoTexture = new THREE.VideoTexture(videoEl);
      const material = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
      videoMesh = new THREE.Mesh(geometry, material);
      videoMesh.visible = false;

      // Инвертируем по X, чтобы убрать зеркальность
      videoMesh.scale.x = -1;

      scene.object3D.add(videoMesh);
    } else {
      videoMesh.geometry.dispose();
      videoMesh.geometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
    }
  });
});

// ------------------- Спавн видео и кнопок по тапу -------------------
scene.addEventListener('click', async event => {
  if(!videoMesh || !videoEl) return;

  if(firstInteraction){
    try{ await videoEl.play(); } catch(e){}
    firstInteraction = false;
  }

  // Позиция видео
  const touchX = event.clientX / window.innerWidth * 2 - 1;
  const touchY = - (event.clientY / window.innerHeight) * 2 + 1;
  const camera = scene.camera;
  const vector = new THREE.Vector3(touchX, touchY, -1).unproject(camera);
  const dir = vector.sub(camera.position).normalize();
  const distance = 2;
  const pos = camera.position.clone().add(dir.multiplyScalar(distance));

  videoMesh.position.copy(pos);
  videoMesh.visible = true;
  videoMesh.rotation.set(0, Math.PI, 0);

  // Создаем кнопки один раз
  if(!buttonGroup){
    buttonGroup = new THREE.Group();
    const spacing = 0.3;

    buttonsData.forEach((b,i)=>{
      const btnGeom = new THREE.PlaneGeometry(0.25,0.08);
      const btnMat = new THREE.MeshBasicMaterial({color:0x0000ff, transparent:true, opacity:0.6});
      const btnMesh = new THREE.Mesh(btnGeom, btnMat);

      // Текст на кнопке
      const loader = new THREE.FontLoader();
      loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font){
        const textGeom = new THREE.TextGeometry(b.name,{
          font: font,
          size:0.04,
          height:0.01
        });
        const textMat = new THREE.MeshBasicMaterial({color:0xffffff});
        const textMesh = new THREE.Mesh(textGeom,textMat);
        textGeom.computeBoundingBox();
        const textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;
        textMesh.position.set(-textWidth/2, -0.02, 0.01);
        btnMesh.add(textMesh);
      });

      // Прогресс-кружок
      const circleGeom = new THREE.RingGeometry(0.01,0.015,32,1,0,0);
      const circleMat = new THREE.MeshBasicMaterial({color:0x000000, side:THREE.DoubleSide});
      const circleMesh = new THREE.Mesh(circleGeom, circleMat);
      circleMesh.position.set(0,0,0.02);
      circleMesh.progress=0;
      btnMesh.add(circleMesh);

      // Наведение через центр камеры (raycaster)
      let hovering=false;
      btnMesh.onHover=true;
      scene.addEventListener('tick', ()=>{
        if(!btnMesh.onHover) return;
        const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
        const ray = new THREE.Ray(camera.position, camDir);
        const intersects = ray.intersectObject(btnMesh,true);
        hovering = intersects.length>0;

        if(hovering){
          circleMesh.progress += scene.clock? scene.clock.getDelta()/3 : 0.016/3;
          circleMesh.geometry.dispose();
          circleMesh.geometry = new THREE.RingGeometry(0.01,0.015,32,1,0,circleMesh.progress*2*Math.PI);
          if(circleMesh.progress>=1){
            b.action();
            circleMesh.progress=0;
            circleMesh.geometry.dispose();
            circleMesh.geometry = new THREE.RingGeometry(0.01,0.015,32,1,0,0);
          }
        } else {
          circleMesh.progress=0;
          circleMesh.geometry.dispose();
          circleMesh.geometry = new THREE.RingGeometry(0.01,0.015,32,1,0,0);
        }
      });

      btnMesh.position.set((i-1.5)*spacing,-videoHeight/2-0.15,-1.5);
      buttonGroup.add(btnMesh);
    });

    scene.object3D.add(buttonGroup);
  }
});

// ------------------- Масштабирование -------------------
let startDistance = null;
let startScale = 1;
scene.addEventListener('touchstart', e=>{
  if(e.touches.length==2 && videoMesh){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    startDistance = Math.sqrt(dx*dx + dy*dy);
    startScale = videoMesh.scale.x;
  }
});

scene.addEventListener('touchmove', e=>{
  if(e.touches.length==2 && videoMesh && startDistance){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const newDistance = Math.sqrt(dx*dx + dy*dy);
    const scaleFactor = newDistance / startDistance;

    videoMesh.scale.set(startScale*scaleFactor,startScale*scaleFactor,1);
    if(buttonGroup) buttonGroup.scale.set(scaleFactor,scaleFactor,1);
  }
});

// ------------------- Видео всегда смотрит на камеру -------------------
scene.addEventListener('tick', ()=>{
  if(videoMesh && videoMesh.visible){
    videoMesh.lookAt(scene.camera.position);
  }
});
</script>
</body>
</html>
