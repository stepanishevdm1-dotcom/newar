<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>AR Видео с кнопками</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://cdn.rawgit.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
<style>
  body { margin:0; overflow:hidden; }
  #fileInput {
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    z-index:10; background: rgba(0,0,0,0.5); color:white; padding:5px 10px; border-radius:5px;
  }
</style>
</head>
<body>
<input type="file" id="fileInput" accept="video/*">

<a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;">
  <a-entity id="camera" camera look-controls>
    <a-entity id="cursor" cursor="fuse: true; fuseTimeout: 3000" position="0 0 -1"
              geometry="primitive:ring; radiusInner:0.005; radiusOuter:0.01"
              material="color:black; shader:flat"></a-entity>
  </a-entity>
</a-scene>

<script>
const scene = document.querySelector('a-scene');
const camera = document.getElementById('camera');
const fileInput = document.getElementById('fileInput');

let videoEl, videoMesh, videoTexture;
let videoWidth = 1, videoHeight = 0.6;
let firstInteraction = true;
let buttons = [];
let buttonData = [
  {name:'Воспроизвести', offsetX:-0.6, action:()=>videoEl.play()},
  {name:'Пауза', offsetX:-0.2, action:()=>videoEl.pause()},
  {name:'Назад 5с', offsetX:0.2, action:()=>videoEl.currentTime-=5},
  {name:'Вперед 5с', offsetX:0.6, action:()=>videoEl.currentTime+=5},
];

// ----------------- Загрузка видео -----------------
fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const url = URL.createObjectURL(file);

  videoEl = document.createElement('video');
  videoEl.src = url;
  videoEl.loop = true;
  videoEl.muted = false;
  videoEl.playsInline = true;
  videoEl.crossOrigin = 'anonymous';

  videoEl.addEventListener('loadeddata', () => {
    videoWidth = videoEl.videoWidth / videoEl.videoHeight;
    videoHeight = 1;

    if(!videoMesh){
      const geometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
      videoTexture = new THREE.VideoTexture(videoEl);
      const material = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
      videoMesh = new THREE.Mesh(geometry, material);
      videoMesh.visible = false;
      videoMesh.scale.x = -1; // зеркалирование
      scene.object3D.add(videoMesh);

      // создаем кнопки после загрузки видео
      createButtons();
    } else {
      videoMesh.geometry.dispose();
      videoMesh.geometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
    }
  });
});

// ----------------- Кнопки -----------------
function createButtons(){
  buttons = [];
  buttonData.forEach(b=>{
    const btn = document.createElement('a-entity');
    btn.setAttribute('geometry',`primitive: plane; width:0.25; height:0.08`);
    btn.setAttribute('material','color:blue; opacity:0.6');
    btn.object3D.position.set(b.offsetX, -0.9, -1.5);

    // текст
    const text = document.createElement('a-entity');
    text.setAttribute('text', `value:${b.name}; align:center; color:white; width:2`);
    text.object3D.position.set(0,0,0.01);
    btn.appendChild(text);

    // прогресс круг
    const progress = document.createElement('a-entity');
    progress.setAttribute('geometry','primitive:ring; radiusInner:0.02; radiusOuter:0.025');
    progress.setAttribute('material','color:white; shader:flat; opacity:0.8');
    progress.object3D.position.set(0,0,0.02);
    btn.appendChild(progress);
    progress.progress = 0;
    progress.updateProgress = function(dt){
      this.progress += dt/3000;
      this.setAttribute('geometry',`primitive:ring; radiusInner:0.02; radiusOuter:0.025; thetaLength:${Math.min(this.progress*360,360)}`);
      if(this.progress>=1){ b.action(); this.progress=0; }
    }

    buttons.push({btn, progress});
    scene.appendChild(btn);

    // наведение
    let hovering=false;
    btn.addEventListener('mouseenter', ()=>{
      hovering=true;
    });
    btn.addEventListener('mouseleave', ()=>{
      hovering=false;
      progress.progress=0;
      progress.setAttribute('geometry',`primitive:ring; radiusInner:0.02; radiusOuter:0.025; thetaLength:0`);
    });

    // обновление прогресса каждый кадр
    scene.addEventListener('tick', ()=>{
      if(hovering) progress.updateProgress(16);
    });
  });
}

// ----------------- Установка видео -----------------
scene.addEventListener('click', event=>{
  if(!videoMesh || !videoEl) return;

  const vector = new THREE.Vector3(0,0,-1);
  vector.unproject(camera.object3D.children[0]);
  const dir = vector.sub(camera.object3D.position).normalize();
  const distance = 2;
  const pos = camera.object3D.position.clone().add(dir.multiplyScalar(distance));

  videoMesh.position.copy(pos);
  videoMesh.visible = true;

  // перемещаем кнопки вместе с видео
  buttons.forEach((b,i)=>{
    b.btn.object3D.position.x = buttonData[i].offsetX;
    b.btn.object3D.position.y = -0.9;
    b.btn.object3D.position.z = -1.5;
  });

  if(firstInteraction){
    videoEl.play().catch(()=>{});
    firstInteraction=false;
  }
});

// ----------------- Масштабирование -----------------
let startDistance=null;
let startScale=1;
scene.addEventListener('touchstart', e=>{
  if(e.touches.length==2 && videoMesh){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    startDistance=Math.sqrt(dx*dx+dy*dy);
    startScale=Math.abs(videoMesh.scale.x);
  }
});
scene.addEventListener('touchmove', e=>{
  if(e.touches.length==2 && videoMesh && startDistance){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const newDistance=Math.sqrt(dx*dx+dy*dy);
    const scaleFactor=newDistance/startDistance;
    videoMesh.scale.set(-startScale*scaleFactor,startScale*scaleFactor,1);

    // масштабируем кнопки вместе с видео
    buttons.forEach(b=>{
      b.btn.object3D.scale.set(scaleFactor,scaleFactor,1);
    });
  }
});

// ----------------- Видео всегда смотрит на камеру -----------------
scene.addEventListener('tick', ()=>{
  if(videoMesh && videoMesh.visible){
    videoMesh.lookAt(camera.object3D.position);
  }
});
</script>
</body>
</html>
