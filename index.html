<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>AR Видео с кнопками фокусировки</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://cdn.rawgit.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
<style>
  body { margin:0; overflow:hidden; }
  #fileInput {
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    z-index:10; background: rgba(0,0,0,0.5); color:white; padding:5px 10px; border-radius:5px;
  }
</style>
</head>
<body>
<input type="file" id="fileInput" accept="video/*">

<a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;'>
  <a-entity camera look-controls>
    <!-- Курсор в центре для фокусировки -->
    <a-entity cursor="fuse: true; fuseTimeout: 3000" position="0 0 -1"
              geometry="primitive: ring; radiusInner: 0.02; radiusOuter: 0.03"
              material="color: yellow; shader: flat"></a-entity>
  </a-entity>
</a-scene>

<script>
const scene = document.querySelector('a-scene');
const fileInput = document.getElementById('fileInput');

let videoEl, videoMesh, videoTexture;
let videoWidth = 1, videoHeight = 0.6;
let firstInteraction = true;

fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const url = URL.createObjectURL(file);

  videoEl = document.createElement('video');
  videoEl.src = url;
  videoEl.loop = true;
  videoEl.muted = false; 
  videoEl.playsInline = true;
  videoEl.crossOrigin = 'anonymous';

  videoEl.addEventListener('loadeddata', () => {
    videoWidth = videoEl.videoWidth / videoEl.videoHeight;
    videoHeight = 1;

    if(!videoMesh){
      const geometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
      videoTexture = new THREE.VideoTexture(videoEl);
      videoTexture.minFilter = THREE.LinearFilter;
      videoTexture.magFilter = THREE.LinearFilter;
      const material = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
      videoMesh = new THREE.Mesh(geometry, material);
      videoMesh.visible = false;
      scene.object3D.add(videoMesh);

      // исправляем зеркалирование
      videoMesh.scale.x = -1;
    } else {
      videoMesh.geometry.dispose();
      videoMesh.geometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
    }
  });
});

// Ставим видео вертикально лицом к камере
scene.addEventListener('click', event => {
  if(!videoMesh || !videoEl) return;

  const touchX = event.clientX / window.innerWidth * 2 - 1;
  const touchY = - (event.clientY / window.innerHeight) * 2 + 1;

  const camera = scene.camera;
  const vector = new THREE.Vector3(touchX, touchY, -1).unproject(camera);
  const dir = vector.sub(camera.position).normalize();
  const distance = 2;
  const pos = camera.position.clone().add(dir.multiplyScalar(distance));

  videoMesh.position.copy(pos);
  videoMesh.visible = true;
  videoMesh.rotation.set(0, Math.PI, 0); 
  videoMesh.scale.set(-1,1,1); // отражение исправлено

  if(firstInteraction){
    videoEl.play().catch(()=>{});
    firstInteraction = false;
  }
});

// Масштабирование пальцами пропорционально
let startDistance = null;
let startScale = 1;
scene.addEventListener('touchstart', e => {
  if(e.touches.length == 2 && videoMesh){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    startDistance = Math.sqrt(dx*dx + dy*dy);
    startScale = Math.abs(videoMesh.scale.x);
  }
});
scene.addEventListener('touchmove', e => {
  if(e.touches.length == 2 && videoMesh && startDistance){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const newDistance = Math.sqrt(dx*dx + dy*dy);
    const scaleFactor = newDistance / startDistance;
    videoMesh.scale.set(-startScale*scaleFactor, startScale*scaleFactor,1);
  }
});

// ----------------- Кнопки -----------------
const buttonData = [
  {name:'play', x:-0.5, y:-1, action:()=>videoEl.play()},
  {name:'pause', x:0, y:-1, action:()=>videoEl.pause()},
  {name:'back', x:-1, y:-1, action:()=>videoEl.currentTime-=5},
  {name:'forward', x:1, y:-1, action:()=>videoEl.currentTime+=5},
  {name:'vol+', x:1.5, y:-1, action:()=>{ videoEl.volume = Math.min(videoEl.volume+0.1,1)}},
  {name:'vol-', x:-1.5, y:-1, action:()=>{ videoEl.volume = Math.max(videoEl.volume-0.1,0)}}
];

buttonData.forEach(b=>{
  const btn = document.createElement('a-entity');
  btn.setAttribute('geometry','primitive: plane; width:0.3; height:0.1');
  btn.setAttribute('material','color:blue; opacity:0.6');
  btn.object3D.position.set(b.x,b.y,-2);
  btn.elName = b.name;
  btn.action = b.action;
  scene.appendChild(btn);

  // добавим систему фокусировки
  let focusTimer = null;
  btn.addEventListener('mouseenter', ()=>{ 
    focusTimer = setTimeout(()=>{ b.action(); },3000); 
  });
  btn.addEventListener('mouseleave', ()=>{ clearTimeout(focusTimer); });
});
</script>
</body>
</html>
