<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>AR –í–∏–¥–µ–æ —Å –∫–Ω–æ–ø–∫–æ–π —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://cdn.rawgit.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
<style>
body { margin:0; overflow:hidden; background: #111; font-family: sans-serif; }
#fileInput {
    position:fixed; top:15px; left:50%; transform:translateX(-50%); z-index:10;
    background: rgba(255,255,255,0.95); color:#2c3e50;
    padding:15px 35px; border-radius:50px; border:2px solid #3498db;
    font-size:16px; font-weight:600; cursor:pointer; box-shadow:0 4px 15px rgba(52,152,219,0.3);
    transition: all 0.3s ease;
}
#fileInput:hover { transform:translateX(-50%) scale(1.05); }
#placeBtn {
    position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
    z-index:10; background: linear-gradient(135deg, #3498db, #2ecc71);
    color:white; padding:20px 50px; border-radius:50px; font-size:20px; font-weight:700;
    cursor:pointer; border:none; box-shadow:0 6px 20px rgba(46,204,113,0.4); transition: all 0.3s ease;
}
#placeBtn:hover { transform:translateX(-50%) scale(1.1); }
#videoTime {
    position:fixed; top:15px; right:15px; color:white; background: rgba(0,0,0,0.7);
    padding:10px 20px; border-radius:10px; font-size:16px; font-weight:600;
}
</style>
</head>
<body>
<input type="file" id="fileInput" accept="video/*">
<div id="videoTime">00:00 / 00:00</div>
<div id="placeBtn">üé¨ –†–∞–∑–º–µ—Å—Ç–∏—Ç—å –≤–∏–¥–µ–æ</div>
<div class="loading-spinner" id="loadingSpinner" style="display:none;"></div>

<a-scene 
    embedded
    vr-mode-ui="enabled: false"
    arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;
          sourceWidth: 640; sourceHeight: 360;
          displayWidth: window.innerWidth; displayHeight: window.innerHeight;">
    
    <a-entity camera="fov: 60" look-controls>
        <a-cursor id="main-cursor"
                  fuse="true" fuse-timeout="2000"
                  raycaster="objects: .clickable"
                  geometry="primitive: ring; radiusInner: 0.006; radiusOuter: 0.012"
                  material="color: #3498db; shader: flat; opacity: 0.8"
                  position="0 0 -1"></a-cursor>
    </a-entity>
    
    <a-entity light="type: ambient; color: #666; intensity: 0.8"></a-entity>
    <a-entity light="type: directional; color: #fff; intensity: 0.5" position="-1 2 1"></a-entity>
</a-scene>

<script>
const scene = document.querySelector('a-scene');
const fileInput = document.getElementById('fileInput');
const placeBtn = document.getElementById('placeBtn');
const timeEl = document.getElementById('videoTime');
const loadingSpinner = document.getElementById('loadingSpinner');

let videoEl, videoTexture, videoContainer, videoMesh;
let isPlaced = false;
let firstInteraction = true;
let currentScale = 1;
let updateTimeInterval = null;
let videoWidth = 1.2;
let videoHeight = 0.8;

// –ó–∞–≥—Ä—É–∑–∫–∞ –≤–∏–¥–µ–æ
fileInput.addEventListener('change', async e => {
    const file = e.target.files[0];
    if(!file) return;
    loadingSpinner.style.display = 'block';
    try {
        if(videoEl && videoEl.src) URL.revokeObjectURL(videoEl.src);
        const url = URL.createObjectURL(file);
        videoEl = document.createElement('video');
        videoEl.src = url;
        videoEl.loop = true;
        videoEl.muted = true;
        videoEl.playsInline = true;
        videoEl.crossOrigin = 'anonymous';
        await new Promise(resolve => videoEl.addEventListener('loadeddata', resolve, { once: true }));
        
        const aspectRatio = videoEl.videoWidth / videoEl.videoHeight;
        // –ú–∞—Å—à—Ç–∞–± 0.6√ó
        if(videoEl.videoHeight > videoEl.videoWidth){
            videoWidth = 0.8*0.6; 
            videoHeight = videoWidth / aspectRatio;
        } else {
            videoHeight = 1.0*0.6; 
            videoWidth = videoHeight * aspectRatio;
        }

        if(videoTexture) videoTexture.dispose();
        videoTexture = new THREE.VideoTexture(videoEl);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.format = THREE.RGBAFormat;
    } catch(e){ console.error(e); }
    loadingSpinner.style.display = 'none';
});

// –¢–∞–π–º–µ—Ä –≤–∏–¥–µ–æ
function startTimeUpdate(){
    if(updateTimeInterval) clearInterval(updateTimeInterval);
    updateTimeInterval = setInterval(()=>{
        if(videoEl && videoEl.duration){
            const f = t=>`${Math.floor(t/60).toString().padStart(2,'0')}:${Math.floor(t%60).toString().padStart(2,'0')}`;
            timeEl.textContent = `${f(videoEl.currentTime)} / ${f(videoEl.duration)}`;
        }
    }, 300);
}

// –†–∞–∑–º–µ—â–µ–Ω–∏–µ –≤–∏–¥–µ–æ
placeBtn.addEventListener('click', () => {
    if(!videoEl || !videoTexture){ alert('–í—ã–±–µ—Ä–∏—Ç–µ –≤–∏–¥–µ–æ'); return; }
    const camera = scene.camera;
    const distance = 1.5;

    if(!videoContainer){
        videoContainer = new THREE.Group();
        scene.object3D.add(videoContainer);

        const geometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
        const material = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
        videoMesh = new THREE.Mesh(geometry, material);
        videoContainer.add(videoMesh);
    }

    const pos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(distance));
    videoContainer.position.copy(pos);
    videoContainer.rotation.set(0,0,0);
    videoContainer.scale.set(currentScale,currentScale,currentScale);

    if(firstInteraction){
        videoEl.muted = false;
        videoEl.play().catch(e=>console.log(e));
        firstInteraction=false;
        startTimeUpdate();
    }
    isPlaced=true;
    placeBtn.textContent='üìå –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤–∏–¥–µ–æ';
});

// –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –≤—Ä–∞—â–µ–Ω–∏–µ
let startDistance=null, startScale=1, isRotating=false, lastTouchX=0;

scene.addEventListener('touchstart', e=>{
    if(e.touches.length==2 && videoContainer){
        const dx=e.touches[0].clientX-e.touches[1].clientX;
        const dy=e.touches[0].clientY-e.touches[1].clientY;
        startDistance=Math.sqrt(dx*dx+dy*dy);
        startScale=currentScale;
    }
    if(e.touches.length==1 && videoContainer){
        isRotating=true;
        lastTouchX=e.touches[0].clientX;
    }
});

scene.addEventListener('touchmove', e=>{
    if(e.touches.length==2 && videoContainer && startDistance){
        e.preventDefault();
        const dx=e.touches[0].clientX-e.touches[1].clientX;
        const dy=e.touches[0].clientY-e.touches[1].clientY;
        const currentDistance=Math.sqrt(dx*dx+dy*dy);
        const newScale=Math.max(0.1, Math.min(5, startScale*currentDistance/startDistance));
        videoContainer.scale.set(newScale,newScale,newScale);
        currentScale=newScale;
    }
    if(isRotating && videoContainer && e.touches.length==1){
        e.preventDefault();
        const deltaX=e.touches[0].clientX-lastTouchX;
        videoContainer.rotation.y+=deltaX*0.01;
        lastTouchX=e.touches[0].clientX;
    }
});

scene.addEventListener('touchend', ()=>{ startDistance=null; isRotating=false; });

// –û—á–∏—Å—Ç–∫–∞
window.addEventListener('beforeunload', ()=>{
    if(videoEl && videoEl.src) URL.revokeObjectURL(videoEl.src);
    if(updateTimeInterval) clearInterval(updateTimeInterval);
});
</script>
</body>
</html>
