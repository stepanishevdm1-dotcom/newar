<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR Видео с кнопкой разместить</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.rawgit.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
        body { margin:0; overflow:hidden; }
        #fileInput {
            position:fixed; top:10px; left:50%; 
            transform:translateX(-50%); z-index:10;
            background: rgba(0,0,0,0.5); color:white;
            padding:5px 10px; border-radius:5px;
        }
        #placeBtn {
            position:fixed; bottom:10px; left:50%;
            transform:translateX(-50%); z-index:10;
            background: rgba(0,0,0,0.5); color:white;
            padding:10px 20px; border-radius:5px;
            font-size:16px; cursor:pointer;
        }
        #videoTime {
            position: fixed; top: 10px; right: 10px;
            color: white; background: rgba(0,0,0,0.6);
            padding: 5px 10px; border-radius: 5px;
            font-family: monospace; z-index: 10;
        }
    </style>
</head>
<body>
    <input type="file" id="fileInput" accept="video/*">
    <div id="videoTime">00:00 / 00:00</div>
    <div id="placeBtn">Разместить видео</div>
    
    <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;' cursor="rayOrigin: mouse">
        <a-entity camera look-controls>
            <!-- Курсор в виде кольца с fuse-эффектом -->
            <a-cursor id="main-cursor"
                     fuse="true"
                     fuse-timeout="2000"
                     raycaster="objects: [cursor-listener]"
                     geometry="primitive: ring; radiusInner: 0.008; radiusOuter: 0.016"
                     material="color: #18A0FB; shader: flat"
                     position="0 0 -1"
                     animation__click="property: scale; startEvents: click; easing: easeInCubic; dur: 150; from: 0.1 0.1 0.1; to: 1 1 1"
                     animation__fusing="property: scale; startEvents: fusing; easing: easeInCubic; dur: 2000; from: 1 1 1; to: 0.1 0.1 0.1"
                     animation__mouseleave="property: scale; startEvents: mouseleave; easing: easeInCubic; dur: 500; to: 1 1 1">
            </a-cursor>
        </a-entity>
    </a-scene>
    
    <script>
        const scene = document.querySelector('a-scene');
        const fileInput = document.getElementById('fileInput');
        const placeBtn = document.getElementById('placeBtn');
        const timeEl = document.getElementById('videoTime');
        
        let videoEl, videoMesh, videoTexture;
        let videoContainer;
        let currentScale = 1;
        let firstInteraction = true;
        let playButton, pauseButton; // Отдельные ссылки на кнопки

        // Загрузка видео
        fileInput.addEventListener('change', e => {
            const file = e.target.files[0];
            if(!file) return;
            
            // Освобождаем предыдущий URL, если был
            if(videoEl && videoEl.src) {
                URL.revokeObjectURL(videoEl.src);
            }
            
            const url = URL.createObjectURL(file);
            videoEl = document.createElement('video');
            videoEl.src = url;
            videoEl.loop = true;
            videoEl.muted = true;
            videoEl.playsInline = true;
            videoEl.crossOrigin = 'anonymous';
            
            videoEl.addEventListener('loadeddata', () => {
                const aspectRatio = videoEl.videoWidth / videoEl.videoHeight;
                
                // Определяем ориентацию видео
                if (videoEl.videoHeight > videoEl.videoWidth) {
                    // Вертикальное видео
                    videoWidth = 0.6;
                    videoHeight = videoWidth / aspectRatio;
                } else {
                    // Горизонтальное видео
                    videoHeight = 0.8;
                    videoWidth = videoHeight * aspectRatio;
                }
                
                if (videoTexture) videoTexture.dispose();
                videoTexture = new THREE.VideoTexture(videoEl);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoTexture.format = THREE.RGBAFormat;
            });
        });

        // Таймер видео
        setInterval(() => {
            if(!videoEl || !videoEl.duration) return;
            const f = t => `${Math.floor(t/60).toString().padStart(2,'0')}:${Math.floor(t%60).toString().padStart(2,'0')}`;
            timeEl.textContent = `${f(videoEl.currentTime)} / ${f(videoEl.duration)}`;
        }, 300);

        // Размещение видео по кнопке
        placeBtn.addEventListener('click', () => {
            if(!videoEl || !videoTexture) return;
            
            // Удаляем старый контейнер, если есть
            if (videoContainer) {
                scene.object3D.remove(videoContainer);
                // Удаляем старые кнопки из сцены
                if (playButton && playButton.parentNode) {
                    scene.removeChild(playButton);
                }
                if (pauseButton && pauseButton.parentNode) {
                    scene.removeChild(pauseButton);
                }
            }
            
            // Позиция перед камерой
            const camera = scene.camera;
            const distance = 1.5;
            const pos = camera.position.clone().add(
                camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(distance)
            );
            
            // Создаем контейнер ТОЛЬКО для видео
            videoContainer = new THREE.Group();
            scene.object3D.add(videoContainer);
            
            // Создаем Mesh для видео
            const geometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
            const material = new THREE.MeshBasicMaterial({
                map: videoTexture,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            
            videoMesh = new THREE.Mesh(geometry, material);
            videoContainer.add(videoMesh);
            
            // Позиционируем контейнер
            videoContainer.position.copy(pos);
            videoContainer.lookAt(camera.position);
            
            currentScale = 1;
            videoContainer.scale.set(currentScale, currentScale, currentScale);
            
            if(firstInteraction){
                videoEl.muted = false;
                videoEl.play().catch(e => console.log('Play error:', e));
                firstInteraction = false;
            }
            
            createButtons(pos);
        });

        // Масштабирование пальцами
        let startDistance = null;
        let startScale = 1;
        
        scene.addEventListener('touchstart', e => {
            if(e.touches.length == 2 && videoContainer){
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                startDistance = Math.sqrt(dx*dx + dy*dy);
                startScale = videoContainer.scale.x;
            }
        });
        
        scene.addEventListener('touchmove', e => {
            if(e.touches.length == 2 && videoContainer && startDistance){
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDistance = Math.sqrt(dx*dx + dy*dy);
                const scaleFactor = currentDistance / startDistance;
                
                const newScale = Math.max(0.1, Math.min(5, startScale * scaleFactor));
                videoContainer.scale.set(newScale, newScale, newScale);
                currentScale = newScale;
                
                // Обновляем позиции кнопок при масштабировании видео
                updateButtonsPosition();
            }
        });
        
        scene.addEventListener('touchend', () => {
            startDistance = null;
        });

        // Создание кнопок под видео (отдельно от видео контейнера)
        function createButtons(videoPos) {
            // Удаляем старые кнопки, если есть
            if (playButton && playButton.parentNode) {
                scene.removeChild(playButton);
            }
            if (pauseButton && pauseButton.parentNode) {
                scene.removeChild(pauseButton);
            }
            
            // Создаем кнопки как отдельные A-Frame элементы
            playButton = createButton('play-btn', videoPos, -0.15, '#4CAF50', 'Play', 'play');
            pauseButton = createButton('pause-btn', videoPos, 0.15, '#FF9800', 'Pause', 'pause');
        }
        
        // Создание одной кнопки
        function createButton(id, videoPos, xOffset, color, text, action) {
            const btn = document.createElement('a-entity');
            btn.setAttribute('id', id);
            btn.setAttribute('cursor-listener', '');
            btn.setAttribute('class', 'clickable');
            
            // Рассчитываем начальную позицию кнопки
            const buttonPos = calculateButtonPosition(videoPos, xOffset);
            btn.setAttribute('position', buttonPos);
            
            // Геометрия кнопки (цилиндр для объема)
            btn.setAttribute('geometry', {
                primitive: 'cylinder',
                radius: 0.08,
                height: 0.02
            });
            
            btn.setAttribute('material', {
                color: color,
                opacity: 0.8,
                transparent: true
            });
            
            // Текст на кнопке - БОЛЬШЕ и ЧЕТЧЕ
            btn.setAttribute('text', {
                value: text,
                align: 'center',
                color: 'white',
                width: 0.6,
                height: 0.3,
                wrapCount: 15,
                font: 'roboto',
                baseline: 'center',
                anchor: 'center'
            });
            
            // Сохраняем данные для обновления позиции
            btn.userData = {
                videoPos: videoPos.clone(),
                xOffset: xOffset,
                action: action
            };
            
            // Обработчики событий
            btn.addEventListener('mouseenter', function() {
                this.setAttribute('material', 'opacity', 1);
                this.setAttribute('animation', {
                    property: 'scale',
                    to: '1.1 1.1 1.1',
                    dur: 200,
                    easing: 'easeOutQuad'
                });
            });
            
            btn.addEventListener('mouseleave', function() {
                this.setAttribute('material', 'opacity', 0.8);
                this.setAttribute('animation', {
                    property: 'scale',
                    to: '1 1 1',
                    dur: 200,
                    easing: 'easeOutQuad'
                });
            });
            
            // Обработчик fuse-события
            btn.addEventListener('fusing', function(e) {
                const progress = e.detail.progress;
                if (progress === 1) {
                    executeButtonAction(action);
                    
                    // Анимация нажатия
                    this.setAttribute('animation', {
                        property: 'scale',
                        from: '1 1 1',
                        to: '0.9 0.9 0.9',
                        dur: 100,
                        easing: 'easeOutQuad'
                    });
                    
                    setTimeout(() => {
                        this.setAttribute('animation', {
                            property: 'scale',
                            from: '0.9 0.9 0.9',
                            to: '1 1 1',
                            dur: 100,
                            easing: 'easeOutQuad'
                        });
                    }, 100);
                }
            });
            
            // Клик для десктопа
            btn.addEventListener('click', function() {
                executeButtonAction(action);
            });
            
            scene.appendChild(btn);
            return btn;
        }
        
        // Расчет позиции кнопки относительно видео
        function calculateButtonPosition(videoPos, xOffset) {
            if (!videoContainer) return videoPos;
            
            // Копируем позицию видео
            const pos = videoPos.clone();
            
            // Добавляем смещение по X
            pos.x += xOffset;
            
            // Смещаем кнопки вниз относительно видео
            // Используем мировые координаты видео для расчета
            const videoWorldPos = new THREE.Vector3();
            videoMesh.getWorldPosition(videoWorldPos);
            
            // Вычисляем нижний край видео в мировых координатах
            const videoBottom = new THREE.Vector3(0, -videoHeight/2, 0);
            videoBottom.applyMatrix4(videoMesh.matrixWorld);
            
            // Позиционируем кнопки ниже видео
            pos.y = videoBottom.y - 0.2; // 0.2 метра ниже видео
            
            return pos;
        }
        
        // Обновление позиций кнопок при масштабировании видео
        function updateButtonsPosition() {
            if (!videoContainer || !videoMesh) return;
            
            // Получаем текущую мировую позицию видео
            const videoWorldPos = new THREE.Vector3();
            videoMesh.getWorldPosition(videoWorldPos);
            
            // Обновляем позиции кнопок
            if (playButton && playButton.userData) {
                const playPos = calculateButtonPosition(videoWorldPos, playButton.userData.xOffset);
                playButton.setAttribute('position', playPos);
                playButton.userData.videoPos = videoWorldPos.clone();
            }
            
            if (pauseButton && pauseButton.userData) {
                const pausePos = calculateButtonPosition(videoWorldPos, pauseButton.userData.xOffset);
                pauseButton.setAttribute('position', pausePos);
                pauseButton.userData.videoPos = videoWorldPos.clone();
            }
        }
        
        // Выполнение действия кнопки
        function executeButtonAction(action) {
            console.log('Button action:', action);
            
            switch(action) {
                case 'play':
                    if (videoEl) {
                        videoEl.play();
                        console.log('Play video');
                        // Визуальная обратная связь
                        if (playButton) {
                            playButton.setAttribute('material', 'color', '#2E7D32'); // Темно-зеленый
                            setTimeout(() => {
                                if (playButton) {
                                    playButton.setAttribute('material', 'color', '#4CAF50');
                                }
                            }, 300);
                        }
                    }
                    break;
                    
                case 'pause':
                    if (videoEl) {
                        videoEl.pause();
                        console.log('Pause video');
                        // Визуальная обратная связь
                        if (pauseButton) {
                            pauseButton.setAttribute('material', 'color', '#EF6C00'); // Темно-оранжевый
                            setTimeout(() => {
                                if (pauseButton) {
                                    pauseButton.setAttribute('material', 'color', '#FF9800');
                                }
                            }, 300);
                        }
                    }
                    break;
            }
        }
        
        // Функция для обновления позиций кнопок в реальном времени
        function animationLoop() {
            if (videoContainer && videoMesh) {
                updateButtonsPosition();
            }
            requestAnimationFrame(animationLoop);
        }
        
        // Запускаем цикл анимации
        animationLoop();
        
        // Обновляем raycaster при добавлении новых объектов
        scene.addEventListener('object3dset', function() {
            const cursor = document.getElementById('main-cursor');
            if (cursor && cursor.components.raycaster) {
                setTimeout(() => {
                    cursor.components.raycaster.refreshObjects();
                }, 100);
            }
        });
        
        // Освобождаем ресурсы при закрытии
        window.addEventListener('beforeunload', () => {
            if (videoEl && videoEl.src) {
                URL.revokeObjectURL(videoEl.src);
            }
        });
    </script>
</body>
</html>
