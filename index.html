<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>AR Видео с кнопками и масштабируемой группой</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://cdn.rawgit.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
<style>
  body { margin:0; overflow:hidden; }
  #fileInput {
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    z-index:10; background: rgba(0,0,0,0.5); color:white; padding:5px 10px; border-radius:5px;
  }
  #placeBtn {
    position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
    z-index:10; background: rgba(0,0,0,0.5); color:white; padding:10px 20px; border-radius:5px;
    font-size:16px; cursor:pointer;
  }
  #videoTime {
    position: fixed;
    top: 10px;
    right: 10px;
    color: white;
    background: rgba(0,0,0,0.6);
    padding: 5px 10px;
    border-radius: 5px;
    font-family: monospace;
    z-index: 10;
  }
</style>
</head>
<body>

<input type="file" id="fileInput" accept="video/*">
<div id="videoTime">00:00 / 00:00</div>
<div id="placeBtn">Разместить видео</div>

<a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;'>

  <!-- Камера с fuse-курсором -->
  <a-entity camera look-controls>
    <a-entity id="cursor" cursor="fuse: true; fuseTimeout: 2000"
      geometry="primitive:ring; radiusInner:0.01; radiusOuter:0.02"
      material="color:white; shader:flat"
      position="0 0 -0.5">
      <a-ring id="fuseRing" radius-inner="0.01" radius-outer="0.02" color="white" rotation="-90 0 0"></a-ring>
    </a-entity>
  </a-entity>

</a-scene>

<script>
const scene = document.querySelector('a-scene');
const fileInput = document.getElementById('fileInput');
const placeBtn = document.getElementById('placeBtn');
const timeEl = document.getElementById('videoTime');

let videoEl, videoTexture;
let videoWidth = 1, videoHeight = 0.6;
let firstInteraction = true;

// Контейнер для видео + кнопок
let groupEntity = null;

// Загрузка видео
fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const url = URL.createObjectURL(file);

  videoEl = document.createElement('video');
  videoEl.src = url;
  videoEl.loop = true;
  videoEl.muted = true; // для автоплей на мобильном
  videoEl.playsInline = true;
  videoEl.crossOrigin = 'anonymous';

  videoEl.addEventListener('loadeddata', () => {
    videoWidth = videoEl.videoWidth / videoEl.videoHeight;
    videoHeight = 1;
    videoTexture = new THREE.VideoTexture(videoEl);
  });
});

// Таймер видео
setInterval(() => {
  if(!videoEl || !videoEl.duration) return;
  const f = t => `${Math.floor(t/60).toString().padStart(2,'0')}:${Math.floor(t%60).toString().padStart(2,'0')}`;
  timeEl.textContent = `${f(videoEl.currentTime)} / ${f(videoEl.duration)}`;
}, 300);

// Размещение видео и кнопок по кнопке
placeBtn.addEventListener('click', () => {
  if(!videoEl) return;

  const camera = scene.camera;
  const distance = 2;
  const pos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(distance));
  pos.y = 0; // на полу

  if(!groupEntity){
    // Создаем группу
    groupEntity = document.createElement('a-entity');
    scene.appendChild(groupEntity);

    // Видео mesh
    const videoPlane = document.createElement('a-plane');
    videoPlane.setAttribute('id','videoPlane');
    videoPlane.setAttribute('width', videoWidth);
    videoPlane.setAttribute('height', videoHeight);
    videoPlane.setAttribute('material','shader: flat; src: #videoTexture');
    videoPlane.setAttribute('rotation','-90 0 0'); // горизонтально
    groupEntity.appendChild(videoPlane);

    // Привяжем THREE.VideoTexture к A-Frame
    videoPlane.addEventListener('loaded', ()=>{
      videoPlane.getObject3D('mesh').material.map = videoTexture;
      videoPlane.getObject3D('mesh').material.needsUpdate = true;
    });

    // Кнопки
    const playBtn = document.createElement('a-plane');
    playBtn.setAttribute('id','playBtn');
    playBtn.setAttribute('class','clickable');
    playBtn.setAttribute('color','#00ff00');
    playBtn.setAttribute('width','0.4');
    playBtn.setAttribute('height','0.15');
    playBtn.setAttribute('position', `-0.25 ${-videoHeight/2-0.2} 0`);
    playBtn.setAttribute('text','value:Play;align:center');
    groupEntity.appendChild(playBtn);

    const pauseBtn = document.createElement('a-plane');
    pauseBtn.setAttribute('id','pauseBtn');
    pauseBtn.setAttribute('class','clickable');
    pauseBtn.setAttribute('color','#ff0000');
    pauseBtn.setAttribute('width','0.4');
    pauseBtn.setAttribute('height','0.15');
    pauseBtn.setAttribute('position', `0.25 ${-videoHeight/2-0.2} 0`);
    pauseBtn.setAttribute('text','value:Pause;align:center');
    groupEntity.appendChild(pauseBtn);

    addFuse(playBtn, () => videoEl.play());
    addFuse(pauseBtn, () => videoEl.pause());
  }

  // Позиция группы
  groupEntity.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);

  if(firstInteraction){
    videoEl.muted = false;
    videoEl.play().catch(()=>{});
    firstInteraction = false;
  }
});

// Масштабирование пальцами
let startDistance = null;
let startScale = 1;
scene.addEventListener('touchstart', e => {
  if(e.touches.length==2 && groupEntity){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    startDistance = Math.sqrt(dx*dx+dy*dy);
    const scale = groupEntity.getAttribute('scale');
    startScale = scale.x;
  }
});
scene.addEventListener('touchmove', e => {
  if(e.touches.length==2 && groupEntity && startDistance){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const newDistance = Math.sqrt(dx*dx+dy*dy);
    const scaleFactor = newDistance/startDistance;
    groupEntity.setAttribute('scale', `${startScale*scaleFactor} ${startScale*scaleFactor} ${startScale*scaleFactor}`);
  }
});

// Fuse с анимацией заполнения
function addFuse(el, callback){
  let timer = null;
  const ring = document.getElementById('fuseRing');
  let start = null;

  el.addEventListener('mouseenter', () => {
    start = performance.now();
    timer = requestAnimationFrame(fill);
  });

  el.addEventListener('mouseleave', () => {
    if(timer) cancelAnimationFrame(timer);
    ring.setAttribute('scale','1 1 1');
    ring.setAttribute('material','color:white');
  });

  function fill(now){
    const elapsed = now - start;
    const progress = Math.min(elapsed/2000,1);
    ring.setAttribute('scale', `1 ${progress} 1`);
    ring.setAttribute('material','color:#00ffff');
    if(progress<1) timer = requestAnimationFrame(fill);
    else {
      callback();
      ring.setAttribute('scale','1 1 1');
      ring.setAttribute('material','color:white');
    }
  }
}
</script>
</body>
</html>
