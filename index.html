<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR Видео с кнопкой разместить</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.rawgit.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
        body { margin:0; overflow:hidden; }
        #fileInput {
            position:fixed; top:10px; left:50%; 
            transform:translateX(-50%); z-index:10;
            background: rgba(0,0,0,0.5); color:white;
            padding:5px 10px; border-radius:5px;
        }
        #placeBtn {
            position:fixed; bottom:10px; left:50%;
            transform:translateX(-50%); z-index:10;
            background: rgba(0,0,0,0.5); color:white;
            padding:10px 20px; border-radius:5px;
            font-size:16px; cursor:pointer;
        }
        #videoTime {
            position: fixed; top: 10px; right: 10px;
            color: white; background: rgba(0,0,0,0.6);
            padding: 5px 10px; border-radius: 5px;
            font-family: monospace; z-index: 10;
        }
    </style>
</head>
<body>
    <input type="file" id="fileInput" accept="video/*">
    <div id="videoTime">00:00 / 00:00</div>
    <div id="placeBtn">Разместить видео</div>
    
    <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;'>
        <a-entity camera look-controls>
            <a-cursor fuse="true" fuse-timeout="2000" 
                     raycaster="objects: .clickable"
                     geometry="primitive:ring; radiusInner:0.01; radiusOuter:0.02"
                     material="color:white; shader:flat">
            </a-cursor>
        </a-entity>
    </a-scene>
    
    <script>
        const scene = document.querySelector('a-scene');
        const fileInput = document.getElementById('fileInput');
        const placeBtn = document.getElementById('placeBtn');
        const timeEl = document.getElementById('videoTime');
        
        let videoEl, videoMesh, videoTexture;
        let videoContainer; // Контейнер для видео и кнопок
        let currentScale = 1;
        let firstInteraction = true;
        let buttonsGroup; // Группа для кнопок
        let fuseTimers = {}; // Таймеры для fuse эффекта
        let fuseProgress = {}; // Прогресс заполнения
        let fuseIndicators = {}; // Индикаторы прогресса

        // Загрузка видео
        fileInput.addEventListener('change', e => {
            const file = e.target.files[0];
            if(!file) return;
            
            // Освобождаем предыдущий URL, если был
            if(videoEl && videoEl.src) {
                URL.revokeObjectURL(videoEl.src);
            }
            
            const url = URL.createObjectURL(file);
            videoEl = document.createElement('video');
            videoEl.src = url;
            videoEl.loop = true;
            videoEl.muted = true;
            videoEl.playsInline = true;
            videoEl.crossOrigin = 'anonymous';
            
            videoEl.addEventListener('loadeddata', () => {
                // Правильный расчет пропорций с учетом ориентации
                const aspectRatio = videoEl.videoWidth / videoEl.videoHeight;
                
                // Если видео вертикальное (высота > ширины)
                if (videoEl.videoHeight > videoEl.videoWidth) {
                    // Для вертикального видео
                    videoWidth = 0.6; // Фиксированная ширина
                    videoHeight = videoWidth / aspectRatio; // Высота рассчитывается
                } else {
                    // Для горизонтального видео
                    videoHeight = 1; // Фиксированная высота
                    videoWidth = videoHeight * aspectRatio; // Ширина рассчитывается
                }
                
                if (videoTexture) videoTexture.dispose();
                videoTexture = new THREE.VideoTexture(videoEl);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoTexture.format = THREE.RGBAFormat;
            });
        });

        // Таймер видео
        setInterval(() => {
            if(!videoEl || !videoEl.duration) return;
            const f = t => `${Math.floor(t/60).toString().padStart(2,'0')}:${Math.floor(t%60).toString().padStart(2,'0')}`;
            timeEl.textContent = `${f(videoEl.currentTime)} / ${f(videoEl.duration)}`;
        }, 300);

        // Размещение видео по кнопке
        placeBtn.addEventListener('click', () => {
            if(!videoEl || !videoTexture) return;
            
            // Позиция перед камерой
            const camera = scene.camera;
            const distance = 2;
            const pos = camera.position.clone().add(
                camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(distance)
            );
            
            // Удаляем старый контейнер, если есть
            if (videoContainer) {
                scene.object3D.remove(videoContainer);
            }
            
            // Создаем контейнер для видео и кнопок
            videoContainer = new THREE.Group();
            scene.object3D.add(videoContainer);
            
            // Создаем Mesh для видео
            const geometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
            const material = new THREE.MeshBasicMaterial({
                map: videoTexture,
                side: THREE.DoubleSide,
                transparent: true
            });
            
            videoMesh = new THREE.Mesh(geometry, material);
            videoContainer.add(videoMesh);
            
            // Позиционируем контейнер
            videoContainer.position.copy(pos);
            
            // Поворачиваем контейнер к камере
            videoContainer.lookAt(camera.position);
            
            currentScale = 1;
            videoContainer.scale.set(currentScale, currentScale, currentScale);
            
            if(firstInteraction){
                videoEl.muted = false;
                videoEl.play().catch(e => console.log('Play error:', e));
                firstInteraction = false;
            }
            
            createButtons();
        });

        // Масштабирование пальцами
        let startDistance = null;
        let startScale = 1;
        
        scene.addEventListener('touchstart', e => {
            if(e.touches.length == 2 && videoContainer){
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                startDistance = Math.sqrt(dx*dx + dy*dy);
                startScale = videoContainer.scale.x;
            }
        });
        
        scene.addEventListener('touchmove', e => {
            if(e.touches.length == 2 && videoContainer && startDistance){
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDistance = Math.sqrt(dx*dx + dy*dy);
                const scaleFactor = currentDistance / startDistance;
                
                // Ограничиваем масштабирование
                const newScale = Math.max(0.1, Math.min(5, startScale * scaleFactor));
                videoContainer.scale.set(newScale, newScale, newScale);
                currentScale = newScale;
            }
        });
        
        scene.addEventListener('touchend', () => {
            startDistance = null;
        });

        // Создание кнопок под видео с fuse эффектом
        function createButtons(){
            // Удаляем старые кнопки, если есть
            if(buttonsGroup) {
                videoContainer.remove(buttonsGroup);
            }
            
            // Создаем группу для кнопок
            buttonsGroup = new THREE.Group();
            videoContainer.add(buttonsGroup);
            
            // Позиция кнопок под видео (в локальных координатах контейнера)
            const buttonY = -videoHeight/2 - 0.2;
            const buttonSpacing = 0.25;
            
            // Создаем кнопки
            createButton('play', -buttonSpacing, buttonY, 0x00ff00, 'Play');
            createButton('pause', buttonSpacing, buttonY, 0xff0000, 'Pause');
            
            // Создаем кнопку закрытия видео
            createButton('close', 0, -videoHeight/2 - 0.1, 0x888888, 'Close');
        }
        
        // Создание одной кнопки с fuse индикатором
        function createButton(id, x, y, color, text) {
            // Основная кнопка
            const buttonGeometry = new THREE.CircleGeometry(0.1, 32);
            const buttonMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7
            });
            
            const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
            button.position.set(x, y, 0.001);
            button.userData = { 
                type: 'button', 
                action: id,
                hovering: false
            };
            
            // Индикатор прогресса (кольцо)
            const indicatorGeometry = new THREE.RingGeometry(0.09, 0.1, 32);
            const indicatorMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
            indicator.position.set(0, 0, 0.002);
            indicator.rotation.z = Math.PI / 2; // Начинаем с верхней точки
            indicator.visible = false;
            
            // Добавляем индикатор к кнопке
            button.add(indicator);
            
            // Сохраняем ссылки
            fuseIndicators[id] = indicator;
            fuseProgress[id] = 0;
            
            // Текст кнопки
            addTextToButton(button, text, 0, 0, 0.003);
            
            buttonsGroup.add(button);
            
            // Настраиваем события
            setupButtonEvents(button, id);
        }
        
        // Настройка событий для кнопки
        function setupButtonEvents(button, id) {
            // Событие при наведении курсора
            button.addEventListener('mouseenter', () => {
                if (!videoEl) return;
                
                button.userData.hovering = true;
                fuseIndicators[id].visible = true;
                fuseProgress[id] = 0;
                
                // Запускаем таймер заполнения
                clearTimeout(fuseTimers[id]);
                
                const startTime = Date.now();
                const duration = 2000; // 2 секунды
                const updateInterval = 50; // Обновляем каждые 50мс
                
                function updateProgress() {
                    if (!button.userData.hovering) return;
                    
                    const elapsed = Date.now() - startTime;
                    fuseProgress[id] = Math.min(elapsed / duration, 1);
                    
                    // Обновляем индикатор
                    if (fuseIndicators[id]) {
                        // Создаем геометрию кольца с учетом прогресса
                        const startAngle = -Math.PI / 2;
                        const endAngle = startAngle + (2 * Math.PI * fuseProgress[id]);
                        
                        const arcGeometry = new THREE.RingGeometry(
                            0.09, 0.1, 32,
                            1, // thetaSegments
                            startAngle, endAngle - startAngle
                        );
                        
                        // Обновляем геометрию
                        fuseIndicators[id].geometry.dispose();
                        fuseIndicators[id].geometry = arcGeometry;
                    }
                    
                    // Если заполнение завершено
                    if (fuseProgress[id] >= 1) {
                        executeButtonAction(id);
                        // Сбрасываем индикатор
                        setTimeout(() => {
                            if (fuseIndicators[id]) {
                                fuseIndicators[id].visible = false;
                            }
                        }, 300);
                    } else {
                        // Продолжаем обновление
                        fuseTimers[id] = setTimeout(updateProgress, updateInterval);
                    }
                }
                
                fuseTimers[id] = setTimeout(updateProgress, updateInterval);
            });
            
            // Событие при уходе курсора
            button.addEventListener('mouseleave', () => {
                button.userData.hovering = false;
                
                // Останавливаем таймер
                clearTimeout(fuseTimers[id]);
                
                // Скрываем индикатор
                if (fuseIndicators[id]) {
                    fuseIndicators[id].visible = false;
                    
                    // Восстанавливаем полное кольцо
                    const fullGeometry = new THREE.RingGeometry(0.09, 0.1, 32);
                    fuseIndicators[id].geometry.dispose();
                    fuseIndicators[id].geometry = fullGeometry;
                    fuseIndicators[id].rotation.z = Math.PI / 2;
                }
                
                fuseProgress[id] = 0;
            });
            
            // Обработка клика (на всякий случай)
            button.addEventListener('click', () => {
                executeButtonAction(id);
            });
        }
        
        // Выполнение действия кнопки
        function executeButtonAction(id) {
            switch(id) {
                case 'play':
                    if (videoEl) {
                        videoEl.play();
                        console.log('Play video');
                    }
                    break;
                case 'pause':
                    if (videoEl) {
                        videoEl.pause();
                        console.log('Pause video');
                    }
                    break;
                case 'close':
                    // Удаляем видео
                    if (videoContainer) {
                        scene.object3D.remove(videoContainer);
                        videoContainer = null;
                        buttonsGroup = null;
                        
                        // Останавливаем видео
                        if (videoEl) {
                            videoEl.pause();
                        }
                    }
                    break;
            }
        }
        
        // Добавление текста на кнопки
        function addTextToButton(button, text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 128;
            
            // Прозрачный фон
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Текст
            context.font = 'bold 24px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            // Добавляем тень для лучшей читаемости
            context.strokeStyle = '#000000';
            context.lineWidth = 3;
            context.strokeText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const textGeometry = new THREE.PlaneGeometry(0.15, 0.15);
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(x, y, z);
            
            button.add(textMesh);
        }
        
        // Обновление raycaster для обнаружения кнопок
        function refreshRaycaster() {
            const cursor = document.querySelector('a-cursor');
            if (cursor && cursor.components.raycaster) {
                // Обновляем список объектов для raycaster
                const raycaster = cursor.components.raycaster;
                raycaster.objects = '.clickable, [raycastable]';
                
                // Добавляем атрибут raycastable к нашим кнопкам
                if (buttonsGroup) {
                    buttonsGroup.traverse((child) => {
                        if (child.userData && child.userData.type === 'button') {
                            child.setAttribute('raycastable', '');
                        }
                    });
                }
                
                raycaster.refreshObjects();
            }
        }
        
        // Освобождаем ресурсы при закрытии
        window.addEventListener('beforeunload', () => {
            if (videoEl && videoEl.src) {
                URL.revokeObjectURL(videoEl.src);
            }
            
            // Очищаем все таймеры
            Object.values(fuseTimers).forEach(timer => {
                clearTimeout(timer);
            });
        });
    </script>
</body>
</html>
