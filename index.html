<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>AR –í–∏–¥–µ–æ —Å –∫–Ω–æ–ø–∫–æ–π —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://cdn.rawgit.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
<style>
body { margin:0; overflow:hidden; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); font-family: 'Segoe UI', system-ui, sans-serif;}
#fileInput {position:fixed; top:15px; left:50%; transform:translateX(-50%); z-index:10; background: rgba(255,255,255,0.95); color:#2c3e50; padding:12px 25px; border-radius:50px; border:2px solid #3498db; font-size:14px; font-weight:600; cursor:pointer; box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3); transition: all 0.3s ease;}
#fileInput:hover {background: white; box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4); transform: translateX(-50%) scale(1.05);}
#placeBtn {position:fixed; bottom:20px; left:50%; transform:translateX(-50%); z-index:10; background: linear-gradient(135deg, #3498db 0%, #2ecc71 100%); color:white; padding:14px 40px; border-radius:50px; font-size:16px; font-weight:600; cursor:pointer; border:none; box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4); transition: all 0.3s ease; letter-spacing: 0.5px;}
#placeBtn:hover {transform: translateX(-50%) scale(1.08); box-shadow: 0 8px 25px rgba(46, 204, 113, 0.6);}
#videoTime {position: fixed; top: 15px; right: 15px; color: white; background: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 25px; font-family: 'Monaco', 'Courier New', monospace; z-index: 10; font-size: 13px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px);}
.a-enter-vr, .a-enter-ar {display: none !important;}
.loading-spinner {position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-radius: 50%; border-top-color: #3498db; animation: spin 1s ease-in-out infinite; z-index: 1000; display: none;}
@keyframes spin { to { transform: translate(-50%, -50%) rotate(360deg); } }
</style>
</head>
<body>
<input type="file" id="fileInput" accept="video/*">
<div id="videoTime">00:00 / 00:00</div>
<div id="placeBtn">üé¨ –†–∞–∑–º–µ—Å—Ç–∏—Ç—å –≤–∏–¥–µ–æ</div>
<div class="loading-spinner" id="loadingSpinner"></div>

<a-scene embedded 
        arjs='sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;' 
        cursor="rayOrigin: mouse"
        vr-mode-ui="enabled: false">

    <a-entity camera look-controls>
        <a-cursor id="main-cursor"
                  fuse="true"
                  fuse-timeout="2000"
                  raycaster="objects: .clickable"
                  geometry="primitive: ring; radiusInner: 0.006; radiusOuter: 0.012"
                  material="color: #3498db; shader: flat; opacity: 0.8"
                  position="0 0 -1"
                  animation__click="property: scale; startEvents: click; easing: easeInCubic; dur: 150; from: 0.1 0.1 0.1; to: 1 1 1"
                  animation__fusing="property: scale; startEvents: fusing; easing: easeInCubic; dur: 2000; from: 1 1 1; to: 0.1 0.1 0.1"
                  animation__mouseleave="property: scale; startEvents: mouseleave; easing: easeInCubic; dur: 500; to: 1 1 1"
                  animation__pulse="property: scale; dir: alternate; dur: 1500; easing: easeInOutSine; loop: true; from: 1 1 1; to: 1.2 1.2 1.2">
        </a-cursor>
    </a-entity>

    <a-entity light="type: ambient; color: #666; intensity: 0.8"></a-entity>
    <a-entity light="type: directional; color: #fff; intensity: 0.5" position="-1 2 1"></a-entity>

</a-scene>

<script>
const scene = document.querySelector('a-scene');
const fileInput = document.getElementById('fileInput');
const placeBtn = document.getElementById('placeBtn');
const timeEl = document.getElementById('videoTime');
const loadingSpinner = document.getElementById('loadingSpinner');

let videoEl, videoMesh, videoTexture, videoContainer;
let currentScale = 1;
let isPlaced = false;
let firstInteraction = true;
let playButton, pauseButton, volumeButton;
let videoWidth = 1.2;
let videoHeight = 0.8;
let timerRequest;

// –ó–∞–≥—Ä—É–∑–∫–∞ –≤–∏–¥–µ–æ
fileInput.addEventListener('change', async e => {
    const file = e.target.files[0];
    if(!file) return;

    loadingSpinner.style.display = 'block';

    try {
        if(videoEl && videoEl.src) URL.revokeObjectURL(videoEl.src);

        const url = URL.createObjectURL(file);
        videoEl = document.createElement('video');
        videoEl.src = url;
        videoEl.loop = true;
        videoEl.muted = true;
        videoEl.playsInline = true;
        videoEl.crossOrigin = 'anonymous';
        videoEl.style.display = 'none';
        document.body.appendChild(videoEl);

        await new Promise(resolve => videoEl.addEventListener('loadeddata', resolve, { once:true }));

        const aspectRatio = videoEl.videoWidth / videoEl.videoHeight;
        if(videoEl.videoHeight > videoEl.videoWidth){
            videoWidth = 0.8;
            videoHeight = videoWidth / aspectRatio;
        } else {
            videoHeight = 1.0;
            videoWidth = videoHeight * aspectRatio;
        }

        if(videoTexture) videoTexture.dispose();
        videoTexture = new THREE.VideoTexture(videoEl);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.format = THREE.RGBAFormat;

    } catch(err){
        console.error('Error loading video:', err);
    } finally{
        loadingSpinner.style.display = 'none';
    }
});

// –¢–∞–π–º–µ—Ä –≤–∏–¥–µ–æ
function startVideoTimer(){
    if(timerRequest) cancelAnimationFrame(timerRequest);
    function update(){
        if(!videoEl) return;
        const f = t => `${Math.floor(t/60).toString().padStart(2,'0')}:${Math.floor(t%60).toString().padStart(2,'0')}`;
        timeEl.textContent = `${f(videoEl.currentTime)} / ${f(videoEl.duration)}`;
        timerRequest = requestAnimationFrame(update);
    }
    update();
}

// –†–∞–∑–º–µ—â–µ–Ω–∏–µ –≤–∏–¥–µ–æ
placeBtn.addEventListener('click', () => {
    if(!videoEl || !videoTexture){
        alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª');
        return;
    }

    const camera = scene.camera;
    const distance = isPlaced ? 1.2 : 1.5;

    if(!videoContainer){
        videoContainer = new THREE.Group();
        scene.object3D.add(videoContainer);

        const geometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
        const material = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide, transparent:true, opacity:1 });
        videoMesh = new THREE.Mesh(geometry, material);
        videoMesh.rotation.set(0,0,0);
        videoContainer.add(videoMesh);

        createButtons();
    }

    // –ü–æ–∑–∏—Ü–∏—è –ø–µ—Ä–µ–¥ –∫–∞–º–µ—Ä–æ–π
    const pos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(distance));
    videoContainer.position.copy(pos);
    videoContainer.rotation.set(0, camera.rotation.y, 0); 
    videoContainer.scale.set(currentScale, currentScale, currentScale);

    if(firstInteraction){
        videoEl.muted = false;
        videoEl.play().catch(e=>console.log(e));
        firstInteraction = false;
    }
    startVideoTimer();
    isPlaced = true;
    placeBtn.textContent = 'üìå –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤–∏–¥–µ–æ';
});

// –ö–Ω–æ–ø–∫–∏
function createButtons(){
    if(playButton) videoContainer.remove(playButton);
    if(pauseButton) videoContainer.remove(pauseButton);
    if(volumeButton) videoContainer.remove(volumeButton);

    const buttonY = -videoHeight/2 - 0.2;
    const buttonSpacing = videoWidth * 0.3;

    playButton = createModernButton('play-btn', -buttonSpacing, buttonY, 0.001, '#2ecc71', '‚ñ∂', 'play');
    pauseButton = createModernButton('pause-btn', 0, buttonY, 0.001, '#e74c3c', '‚è∏', 'pause');
    volumeButton = createModernButton('volume-btn', buttonSpacing, buttonY, 0.001, '#3498db', 'üîä', 'toggleVolume');

    videoContainer.add(playButton);
    videoContainer.add(pauseButton);
    videoContainer.add(volumeButton);
}

function createModernButton(id,x,y,z,color,icon,action){
    const group = new THREE.Group();
    group.userData={id, action, originalColor:new THREE.Color(color), isHovered:false};

    const geom = new THREE.CylinderGeometry(0.06,0.06,0.015,32);
    const mat = new THREE.MeshPhongMaterial({color, transparent:true, opacity:0.9, shininess:30, emissive:new THREE.Color(color).multiplyScalar(0.3)});
    const mesh = new THREE.Mesh(geom, mat);
    mesh.rotation.x = Math.PI/2;

    const iconCanvas = createButtonIcon(icon);
    const iconTex = new THREE.CanvasTexture(iconCanvas);
    const iconMat = new THREE.MeshBasicMaterial({map:iconTex, transparent:true, side:THREE.DoubleSide, alphaTest:0.5});
    const iconMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.08,0.08), iconMat);
    iconMesh.position.z = 0.008;

    const glowMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.07,0.018,32), new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.3, side:THREE.BackSide}));
    glowMesh.rotation.x = Math.PI/2;
    glowMesh.visible=false;

    group.add(glowMesh, mesh, iconMesh);
    group.position.set(x,y,z);

    group.userData.setHover = function(is){
        this.userData.isHovered=is;
        glowMesh.visible=is;
        if(is) { mesh.scale.set(1.1,1.1,1.1); mat.emissive.setHex(0x333333); }
        else { mesh.scale.set(1,1,1); mat.emissive.setHex(0x000000); }
    };

    // –ù–∞–≤–µ–¥–µ–Ω–∏–µ –º—ã—à–∏ —á–µ—Ä–µ–∑ A-Frame
    const afBtn = document.createElement('a-entity');
    afBtn.classList.add('clickable');
    afBtn.setAttribute('geometry',{primitive:'plane', width:0.15, height:0.15});
    afBtn.setAttribute('material',{opacity:0.001, transparent:true});
    afBtn.setAttribute('position',{x:x, y:y, z:0.002});
    afBtn.addEventListener('mouseenter', ()=>group.userData.setHover(true));
    afBtn.addEventListener('mouseleave', ()=>group.userData.setHover(false));
    afBtn.addEventListener('click', ()=>executeButtonAction(action));
    scene.appendChild(afBtn);

    return group;
}

function createButtonIcon(icon){
    const canvas=document.createElement('canvas');
    canvas.width=128; canvas.height=128;
    const ctx=canvas.getContext('2d');
    ctx.clearRect(0,0,128,128);
    ctx.beginPath(); ctx.arc(64,64,50,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.fill();
    ctx.font='bold 60px Arial'; ctx.fillStyle='#FFFFFF'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(icon,64,64);
    return canvas;
}

function executeButtonAction(action){
    switch(action){
        case 'play': videoEl?.play(); startVideoTimer(); break;
        case 'pause': videoEl?.pause(); break;
        case 'toggleVolume':
            if(videoEl){
                videoEl.muted=!videoEl.muted;
                const iconMesh = volumeButton.children[2];
                iconMesh.material.map = new THREE.CanvasTexture(createButtonIcon(videoEl.muted?'üîá':'üîä'));
                iconMesh.material.needsUpdate=true;
            }
            break;
    }
}

// –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞–ª—å—Ü–∞–º–∏
let startDistance=null, startScale=1;
scene.addEventListener('touchstart', e=>{
    if(e.touches.length==2 && videoContainer){
        const dx=e.touches[0].clientX-e.touches[1].clientX;
        const dy=e.touches[0].clientY-e.touches[1].clientY;
        startDistance=Math.sqrt(dx*dx+dy*dy); startScale=videoContainer.scale.x;
    }
});
scene.addEventListener('touchmove', e=>{
    if(e.touches.length==2 && videoContainer && startDistance){
        e.preventDefault();
        const dx=e.touches[0].clientX-e.touches[1].clientX;
        const dy=e.touches[0].clientY-e.touches[1].clientY;
        const scaleFactor=Math.sqrt(dx*dx+dy*dy)/startDistance;
        const newScale=Math.max(0.1,Math.min(5,startScale*scaleFactor));
        videoContainer.scale.set(newScale,newScale,newScale);
        currentScale=newScale;
    }
});
scene.addEventListener('touchend', ()=>startDistance=null);

// –í—Ä–∞—â–µ–Ω–∏–µ –≤–∏–¥–µ–æ
let isRotating=false, lastTouchX=0;
scene.addEventListener('touchstart', e=>{
    if(e.touches.length==1 && videoContainer){isRotating=true; lastTouchX=e.touches[0].clientX;}
});
scene.addEventListener('touchmove', e=>{
    if(isRotating && videoContainer && e.touches.length==1){
        e.preventDefault();
        videoContainer.rotation.y += (e.touches[0].clientX - lastTouchX)*0.01;
        lastTouchX=e.touches[0].clientX;
    }
});
scene.addEventListener('touchend', ()=>{isRotating=false;});

// –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
window.addEventListener('beforeunload', ()=>{ if(videoEl?.src) URL.revokeObjectURL(videoEl.src); });

// –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
window.addEventListener('keydown', e=>{
    if(!videoContainer) return;
    switch(e.key){
        case ' ': videoEl.paused?videoEl.play():videoEl.pause(); startVideoTimer(); break;
        case '+': case '=': currentScale=Math.min(5,currentScale*1.1); videoContainer.scale.set(currentScale,currentScale,currentScale); break;
        case '-': currentScale=Math.max(0.1,currentScale*0.9); videoContainer.scale.set(currentScale,currentScale,currentScale); break;
        case 'r': videoContainer.rotation.y+=0.1; break;
        case 'm': videoEl.muted=!videoEl.muted; break;
    }
});
</script>
</body>
</html>
